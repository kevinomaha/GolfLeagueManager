# Technical Specification - Golf League Management System

## 1. Introduction

This document outlines the technical standards, architecture, and development practices for the Golf League Management System. It serves as a guide for developers to ensure consistency, quality, and maintainability throughout the project lifecycle. This specification is based on the requirements defined in `prd.md`.

## 2. Architecture Overview

The system employs a serverless Single Page Application (SPA) architecture hosted on AWS:

-   **Frontend**: React SPA hosted on S3, delivered via CloudFront.
-   **API**: GraphQL API managed by AWS AppSync.
-   **Backend Logic**: AWS Lambda functions (TypeScript) triggered by AppSync resolvers.
-   **Database**: Amazon DynamoDB using a single-table design approach.
-   **Authentication**: Amazon Cognito User Pools.
-   **Infrastructure Provisioning**: AWS Cloud Development Kit (CDK) using TypeScript.
-   **Notifications**: Amazon SES (email) and SNS (SMS) - *To be implemented*.

This architecture prioritizes scalability, cost-efficiency (pay-per-use), and reduced operational overhead.

## 3. Technology Stack

-   **Frontend**: React (`create-react-app` base), Material-UI (MUI), `react-router-dom`, TypeScript.
-   **API Client**: `aws-amplify/auth` for authentication, `aws-amplify/api-graphql` (or similar) for GraphQL interaction.
-   **Backend**: Node.js runtime for AWS Lambda, TypeScript.
-   **Infrastructure**: AWS CDK v2 (TypeScript).
-   **Database**: AWS DynamoDB.
-   **Authentication**: AWS Cognito.
-   **Source Control**: Git, GitHub.
-   **Testing**: Jest (CDK, Lambda), React Testing Library/Jest (Frontend). Selenium/Cypress may be considered for E2E testing (Phase 9).

## 4. Coding Standards

-   **Language**: TypeScript. Enable `strict` mode in `tsconfig.json` for enhanced type safety.
-   **Formatting**: Use Prettier for automated code formatting. A standard Prettier configuration should be added (`.prettierrc`).
-   **Linting**: Use ESLint for code analysis. A standard ESLint configuration (e.g., extending `eslint:recommended`, `plugin:react/recommended`, `plugin:@typescript-eslint/recommended`) should be added (`.eslintrc.js`).
-   **Naming Conventions**:
    -   Variables, functions: `camelCase`
    -   Components, classes, interfaces, types: `PascalCase`
    -   Constants: `UPPER_SNAKE_CASE`
    -   Files: `kebab-case` (e.g., `user-profile.tsx`) or `PascalCase` for components (`UserProfile.tsx`). Be consistent.
-   **Modularity**: Design for reusability.
    -   **Frontend**: Create small, focused React components.
    -   **Backend**: Lambda functions should ideally perform a single task.
    -   **CDK**: Create reusable Constructs for related infrastructure components.
-   **Error Handling**: Implement robust error handling (try/catch blocks, consistent API error responses, user-friendly error display on the frontend).
-   **Comments**: Add comments for complex logic, non-obvious code sections, or `TODO` markers. Avoid commenting on obvious code.
-   **File Size**: Adhere to the guideline of keeping files under 250 lines where feasible to improve readability and maintainability.

## 5. API Design (GraphQL / AppSync)

-   **Schema**: Adhere to GraphQL best practices. Use clear and consistent naming for types, queries, mutations, and fields.
-   **Authorization**: Implement authorization using AppSync directives integrated with Cognito User Pools (e.g., `@aws_auth(cognito_groups: ["Admins"])`). Start with API Key for initial dev, switch to User Pool auth as planned.
-   **Resolvers**: Lambda functions will serve as resolvers. Keep resolver logic focused.
-   **Data Sources**: Primarily DynamoDB. Define appropriate data source configurations in CDK.

## 6. Database Design (DynamoDB)

-   **Design**: Utilize Single-Table Design principles.
-   **Keys**: Define clear `PK` (Partition Key) and `SK` (Sort Key) strategies based on access patterns.
-   **GSIs**: Create Global Secondary Indexes strategically to support required query patterns, as identified during development.
-   **Attributes**: Use consistent naming for attributes.

## 7. Infrastructure (AWS CDK)

-   **Language**: TypeScript.
-   **Organization**: Keep infrastructure code within the `infra/` directory. Organize into logical stacks or nested stacks if complexity increases.
-   **Constructs**: Favor L2 and L3 constructs where available. Create custom L3 constructs for reusable patterns.
-   **Naming**: Use logical IDs for constructs. AWS resource names will be generated by CDK, but provide meaningful prefixes/suffixes where possible.
-   **Environments**: Parameterize environment-specific configurations (e.g., removal policies, domain names) using CDK context or environment variables.
-   **Outputs**: Use `CfnOutput` to expose important resource identifiers (e.g., User Pool ID, API URL, CloudFront Domain). Avoid outputting sensitive information like API keys directly in production (use Systems Manager Parameter Store or Secrets Manager instead).

## 8. Deployment

-   **Infrastructure**: Use `cdk deploy` command.
-   **Frontend**: Build using `npm run build`, then sync the `build/` directory to the S3 bucket using `aws s3 sync`.
-   **Pipeline**: Implement the CDK deployment pipeline (as planned in `todo.md` Phase 1, Step 5) for automated deployments triggered by Git commits later in the project.

## 9. Source Control (Git / GitHub)

-   **Repository**: Use the designated GitHub repository (`kevinomaha/LeagueManager2`).
-   **Branching Strategy**: Recommend using feature branches:
    -   `main` branch represents production-ready code.
    -   Create branches from `main` for new features (e.g., `feature/login-ui`, `feature/schedule-api`).
    -   Merge feature branches back into `main` via Pull Requests.
-   **Commits**: Write clear, concise commit messages describing the change.
-   **Pull Requests**: Use Pull Requests for merging code into `main`. Require code reviews (if team size permits).
-   **.gitignore**: Maintain `.gitignore` files in the root, `infra`, and `frontend` directories to exclude unnecessary files (e.g., `node_modules`, build artifacts, `.env` files, IDE configuration).

## 10. Testing Strategy

-   **Unit Tests**: Implement unit tests *during* development for:
    -   React Components (using React Testing Library / Jest).
    -   Lambda functions/Business Logic (using Jest).
    -   CDK Constructs (using Jest and CDK assertions).
-   **Integration Tests**: Implement integration tests for the AppSync API (Phase 9, or earlier if feasible).
-   **End-to-End (E2E) Tests**: Implement E2E tests for critical user flows (e.g., login, swap request) using Selenium/Cypress (Phase 9).
-   **Execution**: Integrate tests into local development workflows and potentially into the future CI/CD pipeline.
-   **Code vs. Tests**: Do not modify tests to pass; modify the code to pass the tests.

## 11. Security

-   **Authentication**: Rely on Cognito for secure user management and authentication.
-   **Authorization**: Use Cognito groups and AppSync authorization directives for role-based access control.
-   **Transport**: Enforce HTTPS via CloudFront configuration.
-   **Secrets**: Do not commit secrets (API keys, temporary passwords) directly to Git. Use environment variables or AWS Secrets Manager / Parameter Store, especially for production.
-   **Dependencies**: Regularly audit dependencies (`npm audit`) for vulnerabilities.
-   **Input Validation**: Implement input validation on both frontend and backend (Lambda resolvers) to prevent injection attacks or invalid data.
-   **Least Privilege**: Ensure IAM roles for Lambda functions and other services follow the principle of least privilege.

## 12. Document Purpose & Updates

This document is a living specification and should be updated as technical decisions evolve or new standards are adopted during the project. 